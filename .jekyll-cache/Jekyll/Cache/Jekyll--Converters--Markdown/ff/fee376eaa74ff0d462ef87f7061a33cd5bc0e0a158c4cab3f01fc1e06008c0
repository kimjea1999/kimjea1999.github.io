I"}-<h2 id="1-logic-circuit논리회로">1. Logic Circuit(논리회로)</h2>
<p>논리회로는 true(참), false(거짓)에 대해 논리 연산을 수행하는 회로이다. 우리가 사용하는 TV, 휴대전화, 컴퓨터 등등을 디지털 시스템이라고 부르는데, 이것들은 논리회로로 구성되어 있다.
이것의 작동 원리와 구현 과정이 어떠한가를 배우는 것이 이 과목의 목표인 것 같다.<br />
그래서 이진수와 이진 코드에 대해서도 기초적인 지식이 있어야 한다. 이번 글에서는 이진수와 이진 코드가 무엇인지 각각 알아보도록 하자.</p>

<hr />
<h2 id="2-binary-number이진수">2. Binary Number(이진수)</h2>
<p>이진수는 0과 1로만 이루어진 수 체계이다. (헛소리인데 이진수란 말 정말 재밌다. 정작 이진수엔 2가 없는데!) 논리회로에 대해 공부할 때엔, 십진수와 이진수 간의 진수 변환을 원활하게 할 수 있으면 충분한 것 같다.</p>

<h3 id="2-1-10진수---2진수">2-1. 10진수 -&gt; 2진수</h3>
<p>다음은 정수 10진수를 2진수로 변환하는 과정이다.</p>
<ol>
  <li>주어진 10진수를 2로 나눈다.</li>
  <li>몫과 나머지를 구한다.</li>
  <li>나머지는 그대로 둔다.</li>
  <li>몫이 0이 될 때까지, 몫을 가지고 1-3을 반복한다.</li>
  <li>나머지를 구한 역순으로 나열하면 그것이 변환한 2진수 값이 된다.</li>
</ol>

<p>예를 들어, 10진수 41을 2진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>계산</th>
      <th>몫</th>
      <th>나머지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>41/2</td>
      <td>20</td>
      <td>1</td>
    </tr>
    <tr>
      <td>20/2</td>
      <td>10</td>
      <td>0</td>
    </tr>
    <tr>
      <td>10/2</td>
      <td>5</td>
      <td>0</td>
    </tr>
    <tr>
      <td>5/2</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2/2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1/2</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>결과값은 101001이다.</p>

<p>다음은 소수 10진수를 2진수로 변환하는 과정이다.</p>
<ol>
  <li>주어진 10진수를 2로 곱한다.</li>
  <li>곱한 결과를 정수 부분 + 소수 부분의 형태로 바꾼다.</li>
  <li>정수 부분은 그대로 둔다.</li>
  <li>소수 부분이 0이 될 때까지, 소수 부분을 가지고 1-3을 반복한다.</li>
  <li>소수점 첫 번째 자리부터, 구해 놓은 정수들을 구한 순서대로 나열하면, 그것이 변환한 2진수 값이 된다.</li>
</ol>

<p>예를 들어, 10진수 0.6875를 2진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>계산</th>
      <th>1의 자리 수</th>
      <th>소수</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.6875 * 2 = 1.3750</td>
      <td>1</td>
      <td>0.3750</td>
    </tr>
    <tr>
      <td>0.3750 * 2 = 0.7500</td>
      <td>0</td>
      <td>0.7500</td>
    </tr>
    <tr>
      <td>0.7500 * 2 = 1.5000</td>
      <td>1</td>
      <td>0.5000</td>
    </tr>
    <tr>
      <td>0.5000 * 2 = 1.0000</td>
      <td>1</td>
      <td>0.0000</td>
    </tr>
  </tbody>
</table>

<p>결과값은 0.1011이다. 만약 정수 부분과 소수 부분이 같이 존재한다면, 둘을 분리하여 각각의 방식으로 처리한 다음 더해주면 된다.</p>

<h3 id="2-2-2진수---10진수">2-2. 2진수 -&gt; 10진수</h3>
<p>다음은 정수 2진수를 10진수로 변환하는 과정이다.</p>
<ol>
  <li>각 자리(오른쪽에서부터 n번째)에 2^(n-1)을 곱한다.</li>
  <li>곱한 수를 모두 더한다.</li>
</ol>

<p>예를 들어, 2진수 1001을 10진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>2진수</th>
      <th>계산 결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1 * 2^0 = 1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td>0 * 2^1 = 0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>0 * 2^2 = 0</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>1 * 2^3 = 8</td>
    </tr>
  </tbody>
</table>

<p>결과값은 9이다.</p>

<p>다음은 소수 2진수를 10진수로 변환하는 과정이다.</p>
<ol>
  <li>각 자리(왼쪽에서부터 n번째)에 2^(-n)을 곱한다.</li>
  <li>곱한 수를 모두 더한다.</li>
</ol>

<p>예를 들어, 2진수 0.011을 10진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>2진수</th>
      <th>계산 결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0 * 2^-1 = 0</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>1 * 2^-2 = 0.25</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>1 * 2^-3 = 0.125</td>
    </tr>
  </tbody>
</table>

<p>결과값은 0.375이다. 앞서 말한 것과 마찬가지로, 정수 부분과 소수 부분이 모두 있는 수의 경우 둘을 분리하여 처리하면 된다.</p>

<hr />
<h2 id="3-complement보수">3. Complement(보수)</h2>
<p>보수는 음수를 표현하고 뺄셈을 하기 위해 만든 개념이다. 한 진법에서 사용하는 보수의 종류는 2가지씩이 존재하는데, 그 두 가지가 기수 보수와 감소된 기수 보수이다.<br />
쉽게 설명하여, R진법에서 사용하는 보수에는 R의 보수와 (R-1)의 보수가 존재한다는 소리이다. 10진법에는 10의 보수와 9의 보수가 있고, 2진법에는 2의 보수와 1의 보수가 있다.<br />
각각의 식은 다음과 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R's Complements of N : (r^n) - N
(R-1)'s Complements of N : (r^n - 1) - N

(n은 주어진 N의 자릿수를 뜻함.)
</code></pre></div></div>

<p>10진수 12,345의 10의 보수는 100,000 - 12,345 = 87,655이고, 9의 보수는 99,999 - 12,345 = 87,654가 되겠다.<br />
보다시피 (R-1)의 보수에 1을 더하면 R의 보수가 되며, 그렇게 R의 보수를 구하는 편이 훨씬 간단하다. R진법에서 각 자리의 숫자들은 R-1 이하이므로 뺄 때 아주 편해지기 때문이다.</p>

<p>2진수에서는 R-1의 보수를 구하는 것이 훨씬 간단하다. 10111010의 보수를 구하면,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111111 - 10111010 = 01000101
</code></pre></div></div>

<p>가 되는데, 보면 각 자리의 수를 반전시킨 것과 같다는 걸 알 수 있다.</p>

<p>이렇게 구한 보수의 보수를 취하면, 원래 숫자가 된다는 것도 특징이다.</p>

<hr />
<h2 id="4-signed-binary-number부호화-2진수">4. Signed Binary Number(부호화 2진수)</h2>
<p>보수가 음수를 표현하게 된 이유가 여기서 나온다. 디지털 시스템-쉽게 말해 기기 내부에서는 모든 것들을 다 0과 1로 표현한다. 10진법 숫자든, 2진법 숫자든, 논리값이든, 문자든, 부호든… 
따라서 디지털 시스템 내부에서는 숫자의 +와 -를 인식하지 못한다는 문제가 있다. 부호도 0과 1로 표현히므로. 그래서 처음 머리를 써서 만든 방식은 이렇다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Signed Magnitude : 부호를 나타내는 bit + 수의 크기를 나타내는 bits
</code></pre></div></div>

<p>맨 왼쪽 비트가 0이면 양수, 1이면 음수로 생각하기로 한 것이다. 정수 표현에 사용하는 bit의 개수는 8개이므로, 나머지 7개의 비트로만 수의 크기를 표현한다.
그러면 표현 가능한 정수 범위가 11111111(-127)-01111111(127)가 된다. 근데 이 방식에는 결정적인 <u>두 가지</u> 단점이 존재한다.</p>
<ol>
  <li>계산 시, 부호를 나타내는 bit에 따라 연산을 바꾸어 주어야 한다.
    <ul>
      <li>8 + (-7)과, 00001000 + 10000111은 같은 얘기지만 처리 단계로 가면 차이점이 생긴다. 8 + (-7)은 그냥 더해도 결과가 올바르다. 그런데 00001000 + 10000111을 그냥 더하면? 10001111(-15)가 된다. 
  그래서, 앞의 비트를 뚝 뗀 다음, 0001000 - 0000111 = +0000001 =&gt; <u>0</u>0000001의 처리 과정을 거쳐야 한다.</li>
    </ul>
  </li>
  <li>0이 두 자리나 차지한다. : 00000000(+0) == 10000000(-0)이다.</li>
</ol>

<p>그래도 뭐… Signed Magnitude는 음수를 -를 달아 표현하는 것과 비슷하니 직관적이다.<br />
근데 위의 두 가지 문제를 해결할 수 있는 방법이 바로 보수로 표현하는 방법이다. 보수의 종류가 두 가지이니 표현 방식도 두 가지가 된다.</p>
<ul>
  <li>Signed 1’s Complement : 1의 보수 표현법. 00000000부터 01111111까지는 양수, 10000000부터 11111111까지는 양수의 보수(=음수)로 생각한다.</li>
  <li>Signed 2’s Complement : 2의 보수 표현법. 1의 보수와 양수, 음수 범위는 동일하다.</li>
</ul>

<p>Signed Magnitude의 단점으로 지적한 것 중 1번(계산상 처리 문제)은 둘 다 해당하지 않는다. 덧셈이면 바로 더하면 되고, 뺄셈이면 바로 빼면 된다. 그런데 1의 보수 표현법에도 0이 두 개 존재한다. 00000000의 보수를 취하면 11111111이 되어 -0을 만들 수 있다…<br />
하지만 2의 보수 표현법에서 00000000의 보수를 취하면 11111111 + 1 = (1)00000000 (맨 왼쪽 1은 자릿수를 벗어나서 사라짐)이 되어 -0이 없다. (그래서 2의 보수 표현법은 표현할 수 있는 수가 하나 더 많다. -128)<br />
결론은 2의 보수 표현법이 참 좋다 되시겠다.</p>

<p>마무리로, 10001001을 여러 방식으로 읽은 결과표를 보고 어떻게 다른지 살펴보자.</p>

<table>
  <thead>
    <tr>
      <th>/</th>
      <th>Unsigned</th>
      <th>Signed Magnitude</th>
      <th>Signed 1’s Complement</th>
      <th>Signed 2’s Complement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>reading</td>
      <td>2^7+2^3+1</td>
      <td>1(-)0001001(9)</td>
      <td>(-)01110110 = (-)118</td>
      <td>(-)01110110 + 1 = (-)119</td>
    </tr>
    <tr>
      <td>result</td>
      <td>137</td>
      <td>-9</td>
      <td>-118</td>
      <td>-119</td>
    </tr>
  </tbody>
</table>

<hr />
<h2 id="5-binary-code이진-코드">5. Binary Code(이진 코드)</h2>
<p>이진 코드는 0과 1을 사용하는 코드이다. 결과적으로 2진수와 형태는 유사하지만, 각각의 방식으로 10진수나 부호, 기호, 문자 등등을 표현하는 용도이다.<br />
따라서 용도별로 다양한 종류의 이진 코드가 존재한다. 그 중 여기서는 BCD Code와 Gray Code, ASCII, Error-detecting Code 네 가지를 다룰 것이다.</p>

<h3 id="5-1-bcd-code">5-1. BCD Code</h3>
<p>10진수를 표현하는 데 쓰는 이진 코드이다. 10진수의 각 자릿수마다 4bit씩 할당하여 수를 표현한다. 
예를 들어, 5는 1의 자리 수 밖에 없으므로 4bit만으로 표현할 수 있을 것이고, 225는 100의 자리 수까지 있으므로, 총 12bit를 써서 표현해야 할 것이다.<br />
알기 쉽게 수를 BCD Code로 바꿔 본 예시를 보자.</p>

<table>
  <thead>
    <tr>
      <th>number</th>
      <th>6</th>
      <th>25</th>
      <th>806</th>
      <th>3333</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BCD Code</td>
      <td>0110</td>
      <td>0010 0101</td>
      <td>1000 0000 0110</td>
      <td>0011 0011 0011 0011</td>
    </tr>
  </tbody>
</table>
:ET