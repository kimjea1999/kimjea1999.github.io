I"<<h2 id="1-logic-circuit논리회로">1. Logic Circuit(논리회로)</h2>
<p>논리회로는 true(참), false(거짓)에 대해 논리 연산을 수행하는 회로이다. 우리가 사용하는 TV, 휴대전화, 컴퓨터 등등을 디지털 시스템이라고 부르는데, 이것들은 논리회로로 구성되어 있다.
이것의 작동 원리와 구현 과정이 어떠한가를 배우는 것이 이 과목의 목표인 것 같다.<br />
그래서 이진수와 이진 코드에 대해서도 기초적인 지식이 있어야 한다. 이번 글에서는 이진수와 이진 코드가 무엇인지 각각 알아보도록 하자.</p>

<hr />
<h2 id="2-binary-number이진수">2. Binary Number(이진수)</h2>
<p>이진수는 0과 1로만 이루어진 수 체계이다. (헛소리인데 이진수란 말 정말 재밌다. 정작 이진수엔 2가 없는데!) 논리회로에 대해 공부할 때엔, 십진수와 이진수 간의 진수 변환을 원활하게 할 수 있으면 충분한 것 같다.</p>

<h3 id="2-1-10진수---2진수">2-1. 10진수 -&gt; 2진수</h3>
<p>다음은 정수 10진수를 2진수로 변환하는 과정이다.</p>
<ol>
  <li>주어진 10진수를 2로 나눈다.</li>
  <li>몫과 나머지를 구한다.</li>
  <li>나머지는 그대로 둔다.</li>
  <li>몫이 0이 될 때까지, 몫을 가지고 1-3을 반복한다.</li>
  <li>나머지를 구한 역순으로 나열하면 그것이 변환한 2진수 값이 된다.</li>
</ol>

<p>예를 들어, 10진수 41을 2진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>계산</th>
      <th>몫</th>
      <th>나머지</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>41/2</td>
      <td>20</td>
      <td>1</td>
    </tr>
    <tr>
      <td>20/2</td>
      <td>10</td>
      <td>0</td>
    </tr>
    <tr>
      <td>10/2</td>
      <td>5</td>
      <td>0</td>
    </tr>
    <tr>
      <td>5/2</td>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2/2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1/2</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>결과값은 101001이다.</p>

<p>다음은 소수 10진수를 2진수로 변환하는 과정이다.</p>
<ol>
  <li>주어진 10진수를 2로 곱한다.</li>
  <li>곱한 결과를 정수 부분 + 소수 부분의 형태로 바꾼다.</li>
  <li>정수 부분은 그대로 둔다.</li>
  <li>소수 부분이 0이 될 때까지, 소수 부분을 가지고 1-3을 반복한다.</li>
  <li>소수점 첫 번째 자리부터, 구해 놓은 정수들을 구한 순서대로 나열하면, 그것이 변환한 2진수 값이 된다.</li>
</ol>

<p>예를 들어, 10진수 0.6875를 2진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>계산</th>
      <th>1의 자리 수</th>
      <th>소수</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0.6875 * 2 = 1.3750</td>
      <td>1</td>
      <td>0.3750</td>
    </tr>
    <tr>
      <td>0.3750 * 2 = 0.7500</td>
      <td>0</td>
      <td>0.7500</td>
    </tr>
    <tr>
      <td>0.7500 * 2 = 1.5000</td>
      <td>1</td>
      <td>0.5000</td>
    </tr>
    <tr>
      <td>0.5000 * 2 = 1.0000</td>
      <td>1</td>
      <td>0.0000</td>
    </tr>
  </tbody>
</table>

<p>결과값은 0.1011이다. 만약 정수 부분과 소수 부분이 같이 존재한다면, 둘을 분리하여 각각의 방식으로 처리한 다음 더해주면 된다.</p>

<h3 id="2-2-2진수---10진수">2-2. 2진수 -&gt; 10진수</h3>
<p>다음은 정수 2진수를 10진수로 변환하는 과정이다.</p>
<ol>
  <li>각 자리(오른쪽에서부터 n번째)에 2^(n-1)을 곱한다.</li>
  <li>곱한 수를 모두 더한다.</li>
</ol>

<p>예를 들어, 2진수 1001을 10진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>2진수</th>
      <th>계산 결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1 * 2^0 = 1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0</td>
      <td>0 * 2^1 = 0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0</td>
      <td>0 * 2^2 = 0</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>1 * 2^3 = 8</td>
    </tr>
  </tbody>
</table>

<p>결과값은 9이다.</p>

<p>다음은 소수 2진수를 10진수로 변환하는 과정이다.</p>
<ol>
  <li>각 자리(왼쪽에서부터 n번째)에 2^(-n)을 곱한다.</li>
  <li>곱한 수를 모두 더한다.</li>
</ol>

<p>예를 들어, 2진수 0.011을 10진수로 변환하면,</p>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>2진수</th>
      <th>계산 결과</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0 * 2^-1 = 0</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
      <td>1 * 2^-2 = 0.25</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
      <td>1 * 2^-3 = 0.125</td>
    </tr>
  </tbody>
</table>

<p>결과값은 0.375이다. 앞서 말한 것과 마찬가지로, 정수 부분과 소수 부분이 모두 있는 수의 경우 둘을 분리하여 처리하면 된다.</p>

<hr />
<h2 id="3-complement보수">3. Complement(보수)</h2>
<p>보수는 음수를 표현하고 뺄셈을 하기 위해 만든 개념이다. 한 진법에서 사용하는 보수의 종류는 2가지씩이 존재하는데, 그 두 가지가 기수 보수와 감소된 기수 보수이다.<br />
쉽게 설명하여, R진법에서 사용하는 보수에는 R의 보수와 (R-1)의 보수가 존재한다는 소리이다. 10진법에는 10의 보수와 9의 보수가 있고, 2진법에는 2의 보수와 1의 보수가 있다.<br />
각각의 식은 다음과 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>R's Complements of N : (r^n) - N
(R-1)'s Complements of N : (r^n - 1) - N

(n은 주어진 N의 자릿수를 뜻함.)
</code></pre></div></div>

<p>10진수 12,345의 10의 보수는 100,000 - 12,345 = 87,655이고, 9의 보수는 99,999 - 12,345 = 87,654가 되겠다.<br />
보다시피 (R-1)의 보수에 1을 더하면 R의 보수가 되며, 그렇게 R의 보수를 구하는 편이 훨씬 간단하다. R진법에서 각 자리의 숫자들은 R-1 이하이므로 뺄 때 아주 편해지기 때문이다.</p>

<p>2진수에서는 R-1의 보수를 구하는 것이 훨씬 간단하다. 10111010의 보수를 구하면,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>11111111 - 10111010 = 01000101
</code></pre></div></div>

<p>가 되는데, 보면 각 자리의 수를 반전시킨 것과 같다는 걸 알 수 있다.</p>

<p>이렇게 구한 보수의 보수를 취하면, 원래 숫자가 된다는 것도 특징이다.</p>

<hr />
<h2 id="4-signed-binary-number부호화-2진수">4. Signed Binary Number(부호화 2진수)</h2>
<p>보수가 음수를 표현하게 된 이유가 여기서 나온다. 디지털 시스템-쉽게 말해 기기 내부에서는 모든 것들을 다 0과 1로 표현한다. 10진법 숫자든, 2진법 숫자든, 논리값이든, 문자든, 부호든… 
따라서 디지털 시스템 내부에 숫자의 +와 -를 인식시켜야 한다는 문제가 있다. 그래서 처음 머리를 써서 만든 방식은 이렇다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Signed Magnitude : 부호를 나타내는 bit + 수의 크기를 나타내는 bits
</code></pre></div></div>

<p>맨 왼쪽 비트가 0이면 양수, 1이면 음수로 생각하기로 한 것이다. 정수 표현에 사용하는 bit의 개수는 8개이므로, 나머지 7개의 비트로만 수의 크기를 표현한다.
그러면 표현 가능한 정수 범위가 11111111(-127)-01111111(127)가 된다. 근데 이 방식에는 결정적인 <u>두 가지</u> 단점이 존재한다.</p>
<ol>
  <li>계산 시, 부호를 나타내는 bit에 따라 연산을 바꾸어 주어야 한다.
    <ul>
      <li>8 + (-7)과, 00001000 + 10000111은 같은 얘기지만 처리 단계로 가면 차이점이 생긴다. 8 + (-7)은 그냥 더해도 결과가 올바르다. 그런데 00001000 + 10000111을 그냥 더하면? 10001111(-15)가 된다. 
  그래서, 앞의 비트를 뚝 뗀 다음, 0001000 - 0000111 = +0000001 =&gt; <u>0</u>0000001의 처리 과정을 거쳐야 한다.</li>
    </ul>
  </li>
  <li>0이 두 자리나 차지한다. : 00000000(+0) == 10000000(-0)이다.</li>
</ol>

<p>그래도 뭐… Signed Magnitude는 음수를 -를 달아 표현하는 것과 비슷하니 직관적이다.<br />
근데 위의 두 가지 문제를 해결할 수 있는 방법이 바로 보수로 표현하는 방법이다. 보수의 종류가 두 가지이니 표현 방식도 두 가지가 된다.</p>
<ul>
  <li>Signed 1’s Complement : 1의 보수 표현법. 00000000부터 01111111까지는 양수, 10000000부터 11111111까지는 양수의 보수(=음수)로 생각한다.</li>
  <li>Signed 2’s Complement : 2의 보수 표현법. 1의 보수와 양수, 음수 범위는 동일하다.</li>
</ul>

<p>Signed Magnitude의 단점으로 지적한 것 중 1번(계산상 처리 문제)은 둘 다 해당하지 않는다. 덧셈이면 바로 더하면 되고, 뺄셈이면 바로 빼면 된다. 그런데 1의 보수 표현법에도 0이 두 개 존재한다. 00000000의 보수를 취하면 11111111이 되어 -0을 만들 수 있다…<br />
하지만 2의 보수 표현법에서 00000000의 보수를 취하면 11111111 + 1 = (1)00000000 (맨 왼쪽 1은 자릿수를 벗어나서 사라짐)이 되어 -0이 없다. (그래서 2의 보수 표현법은 표현할 수 있는 수가 하나 더 많다. -128)<br />
결론은 2의 보수 표현법이 참 좋다 되시겠다.</p>

<p>마무리로, 10001001을 여러 방식으로 읽은 결과표를 보고 어떻게 다른지 살펴보자.</p>

<table>
  <thead>
    <tr>
      <th>/</th>
      <th>Unsigned</th>
      <th>Signed Magnitude</th>
      <th>Signed 1’s Complement</th>
      <th>Signed 2’s Complement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>reading</td>
      <td>2^7+2^3+1</td>
      <td>1(-)0001001(9)</td>
      <td>(-)01110110 = (-)118</td>
      <td>(-)01110110 + 1 = (-)119</td>
    </tr>
    <tr>
      <td>result</td>
      <td>137</td>
      <td>-9</td>
      <td>-118</td>
      <td>-119</td>
    </tr>
  </tbody>
</table>

<hr />
<h2 id="5-binary-code이진-코드">5. Binary Code(이진 코드)</h2>
<p>이진 코드는 0과 1을 사용하는 코드이다. 결과적으로 2진수와 형태는 유사하지만, 각각의 방식으로 10진수나 부호, 기호, 문자 등등을 표현하는 용도이다.<br />
따라서 용도별로 다양한 종류의 이진 코드가 존재한다. 그 중 여기서는 BCD Code와 Gray Code, ASCII, Error-detecting Code 네 가지를 다룰 것이다.</p>

<h3 id="5-1-bcd-code">5-1. BCD Code</h3>
<p>10진수를 표현하는 데 쓰는 이진 코드이다. 10진수의 각 자릿수마다 4bit씩 할당하여 수를 표현한다. 
예를 들어, 5는 1의 자리 수 밖에 없으므로 4bit만으로 표현할 수 있을 것이고, 225는 100의 자리 수까지 있으므로, 총 12bit를 써서 표현해야 할 것이다.<br />
알기 쉽게 수를 BCD Code로 바꿔 본 예시를 보자.</p>

<table>
  <thead>
    <tr>
      <th>number</th>
      <th>6</th>
      <th>25</th>
      <th>806</th>
      <th>3333</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BCD Code</td>
      <td>0110(6)</td>
      <td>0010(2) 0101(5)</td>
      <td>1000(8) 0000(0) 0110(6)</td>
      <td>0011(3) 0011(3) 0011(3) 0011(3)</td>
    </tr>
  </tbody>
</table>

<p>더 설명할 것도 없이 간단하니 좋다. 근데 표현한 결과물이 숫자니까, 계산도 하려면 할 수 있어야 되지 않을까? 덧셈, 뺄셈 방법에 대해서도 설명하겠다.</p>

<p><strong>[덧셈하는 방법]</strong><br />
각 자릿수끼리 더하면 된다. 그런데, 어느 자릿수의 덧셈 결과가 10을 넘을 수도 있다. 예를 들면 다음과 같은 경우이다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0010 0111 (27)
+ 0011 0101 (35)
----------------
  0101 1100 (???)
</code></pre></div></div>

<p>고려해야 할 것이 바로 이 부분이다. 10진수는 숫자가 10개밖에 없는데, 4bit는 0부터 15까지 표현할 수 있다. 따라서, 계산 결과로 나온 값이 10 이상이라면 1의 자리 수만 남기고, 다음 자릿수에 1을 더해줘야 제대로 된 값이 된다.<br />
예를 들어 위와 같은 경우라면, 1100(12)는 0001 0010으로 바꾸어주어야 한다. 그러기 위해 1100(12)에 0110(6)을 더해 보자, 값은 18이 된다. 그러면 16(<u>1</u>0000)은 4bit에서 벗어난 값이므로 다음 자리수로 1이 넘어가고, 2만 남는다.<br />
이렇게 10의 자리수만 4bit 바깥으로 밀어내 없애기 위해서는 6을 더하면 된다. 10을 16으로, 11을 17로… 만들 수 있는 수가 6이기 때문이다. 이를 이용해 앞의 잘못된 연산을 바르게 고치면,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0010 0111 (27)
+ 0011 0101 (35)
----------------
  0101 1100 (&gt;= 1010)
     + 0110 (= 6)
----------------
  0101 0010
+ 0001
----------------
  0111 0010 (62)
</code></pre></div></div>

<p>올바른 결과를 얻을 수 있다.</p>

<p><strong>[뺄셈하는 방법]</strong><br />
이건 수업에서 다루지 않았던 내용인데, 지금(대략 7주차) 회로 가지고 가산기 감산기 만들면서 BCD Code 얘기를 다시 하려는 느낌이라 한꺼번에 다루고 가겠다.</p>

<p>BCD Code의 단점 중 하나가 덧셈과 뺄셈 처리 과정이 다르단 것인데, 덧셈과 다르게 뺄셈을 할 때는 보수를 이용한다.</p>
<ol>
  <li>감수(subtrahend - 뺄셈 기호 오른쪽에 있는 수)의 <u>1의 보수</u>를 취한다.</li>
  <li>이 1의 보수를 피감수에 더한다.</li>
  <li>이때, 각 자릿수별로 4bit를 벗어나는 1이 생길 수도 있다. 1이 생긴 자릿수의 다음 자릿수에, 이 1을 더해 준다. 만약 다음 자릿수가 없다면, 1의 자리 수에 그 1을 더한다. 이 과정을 carry라고 부른다. (덧셈에서도 마찬가지)</li>
  <li>carry가 일어나지 않은(즉, 4bit를 벗어나는 1이 없었던) 자릿수에는 1010을 더해 준다. 이때 4bit를 벗어난 값이 생긴다면, 그 수는 그냥 버린다.</li>
</ol>

<p>한국어 정보는 얻기 힘들다고 판단해 영어로 된 글들을 몇 개 참고해서 썼다. MBS니 EAC 같은, 실제 구현에서 써먹을 만한 용어를 싹 제거하고 번역까지 해서 아주 알아듣기 쉬워진 편이다.<br />
이것도 예시와 함께 보자. 이번에는 35에서 27을 빼 보도록 하자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0011 0101 (35)
+ 1101 1000 (1's Complement of 27)
----------------
1 0000 1101 (10의 자리 수에서 carry 발생)

  0000 1101
     +    1 (다음 자릿수(100의 자리)가 없으므로 1의 자리 수에 더한다.)
----------------
  0000 1110
     + 1010 (1의 자리 수에서는 carry가 발생하지 않았으므로 1010을 더한다.)
----------------
 x-&gt;(1)1000 (8)
</code></pre></div></div>

<p>꽤나 복잡한 방법이긴 한데 다른 방식을 찾지 못했다. 만약 시험 문제같은 걸로 출제된다면 그냥 10진법으로 바꿔서 계산하고 BCD로 변환하는 것이 훨씬 빠를 것이다. 컴퓨터가 이걸 못할 뿐.</p>

:ET