---
layout: post
title:  "논리회로와 이진수, 이진 코드"
date:   2020-04-26 12:15:00 +0530 
category: [Logic Circuit]
---

## 1. Logic Circuit(논리회로)
논리회로는 true(참), false(거짓)에 대해 논리 연산을 수행하는 회로이다. 우리가 사용하는 TV, 휴대전화, 컴퓨터 등등을 디지털 시스템이라고 부르는데, 이것들은 논리회로로 구성되어 있다.
이것의 작동 원리와 구현 과정이 어떠한가를 배우는 것이 이 과목의 목표인 것 같다.  
그래서 이진수와 이진 코드에 대해서도 기초적인 지식이 있어야 한다. 이번 글에서는 이진수와 이진 코드가 무엇인지 각각 알아보도록 하자.

***
## 2. Binary Number(이진수)
이진수는 0과 1로만 이루어진 수 체계이다. (헛소리인데 이진수란 말 정말 재밌다. 정작 이진수엔 2가 없는데!) 논리회로에 대해 공부할 때엔, 십진수와 이진수 간의 진수 변환을 원활하게 할 수 있으면 충분한 것 같다.  

### 2-1. 10진수 -> 2진수
다음은 정수 10진수를 2진수로 변환하는 과정이다.
 1. 주어진 10진수를 2로 나눈다.
 2. 몫과 나머지를 구한다.
 3. 나머지는 그대로 둔다.
 4. 몫이 0이 될 때까지, 몫을 가지고 1-3을 반복한다.
 5. 나머지를 구한 역순으로 나열하면 그것이 변환한 2진수 값이 된다.

예를 들어, 10진수 41을 2진수로 변환하면,

|계산|몫|나머지|
|---|---|---|
|41/2|20|1|
|20/2|10|0|
|10/2|5|0|
|5/2|2|1|
|2/2|1|0|
|1/2|0|1|

결과값은 101001이다.  

다음은 소수 10진수를 2진수로 변환하는 과정이다.
 1. 주어진 10진수를 2로 곱한다.
 2. 곱한 결과를 정수 부분 + 소수 부분의 형태로 바꾼다.
 3. 정수 부분은 그대로 둔다.
 4. 소수 부분이 0이 될 때까지, 소수 부분을 가지고 1-3을 반복한다.
 5. 소수점 첫 번째 자리부터, 구해 놓은 정수들을 구한 순서대로 나열하면, 그것이 변환한 2진수 값이 된다.

예를 들어, 10진수 0.6875를 2진수로 변환하면,

|계산|1의 자리 수|소수|
|---|---|---|
|0.6875 * 2 = 1.3750|1|0.3750|
|0.3750 * 2 = 0.7500|0|0.7500|
|0.7500 * 2 = 1.5000|1|0.5000|
|0.5000 * 2 = 1.0000|1|0.0000|

결과값은 0.1011이다. 만약 정수 부분과 소수 부분이 같이 존재한다면, 둘을 분리하여 각각의 방식으로 처리한 다음 더해주면 된다.

### 2-2. 2진수 -> 10진수
다음은 정수 2진수를 10진수로 변환하는 과정이다.
 1. 각 자리(오른쪽에서부터 n번째)에 2^(n-1)을 곱한다.
 2. 곱한 수를 모두 더한다.

예를 들어, 2진수 1001을 10진수로 변환하면,

|n|2진수|계산 결과|
|---|---|---|
|1|1|1 * 2^0 = 1|
|2|0|0 * 2^1 = 0|
|3|0|0 * 2^2 = 0|
|4|1|1 * 2^3 = 8|

결과값은 9이다.

다음은 소수 2진수를 10진수로 변환하는 과정이다.
 1. 각 자리(왼쪽에서부터 n번째)에 2^(-n)을 곱한다.
 2. 곱한 수를 모두 더한다.

예를 들어, 2진수 0.011을 10진수로 변환하면,

|n|2진수|계산 결과|
|---|---|---|
|1|0|0 * 2^-1 = 0|
|2|1|1 * 2^-2 = 0.25|
|3|1|1 * 2^-3 = 0.125|

결과값은 0.375이다. 앞서 말한 것과 마찬가지로, 정수 부분과 소수 부분이 모두 있는 수의 경우 둘을 분리하여 처리하면 된다.

***
## 3. Complement(보수)
보수는 음수를 표현하고 뺄셈을 하기 위해 만든 개념이다. 한 진법에서 사용하는 보수의 종류는 2가지씩이 존재하는데, 그 두 가지가 기수 보수와 감소된 기수 보수이다.  
쉽게 설명하여, R진법에서 사용하는 보수에는 R의 보수와 (R-1)의 보수가 존재한다는 소리이다. 10진법에는 10의 보수와 9의 보수가 있고, 2진법에는 2의 보수와 1의 보수가 있다.  
각각의 식은 다음과 같다.
```
R's Complements of N : (r^n) - N
(R-1)'s Complements of N : (r^n - 1) - N

(n은 주어진 N의 자릿수를 뜻함.)
```

10진수 12,345의 10의 보수는 100,000 - 12,345 = 87,655이고, 9의 보수는 99,999 - 12,345 = 87,654가 되겠다.  
보다시피 (R-1)의 보수에 1을 더하면 R의 보수가 되며, 그렇게 R의 보수를 구하는 편이 훨씬 간단하다. R진법에서 각 자리의 숫자들은 R-1 이하이므로 뺄 때 아주 편해지기 때문이다.  

2진수에서는 R-1의 보수를 구하는 것이 훨씬 간단하다. 10111010의 보수를 구하면,
```
11111111 - 10111010 = 01000101
```

가 되는데, 보면 각 자리의 수를 반전시킨 것과 같다는 걸 알 수 있다.  

이렇게 구한 보수의 보수를 취하면, 원래 숫자가 된다는 것도 특징이다.

***
## 4. Signed Binary Number(부호화 2진수)
보수가 음수를 표현하게 된 이유가 여기서 나온다. 디지털 시스템-쉽게 말해 기기 내부에서는 모든 것들을 다 0과 1로 표현한다. 10진법 숫자든, 2진법 숫자든, 논리값이든, 문자든, 부호든... 
따라서 디지털 시스템 내부에 숫자의 +와 -를 인식시켜야 한다는 문제가 있다. 그래서 처음 머리를 써서 만든 방식은 이렇다.  
```
Signed Magnitude : 부호를 나타내는 bit + 수의 크기를 나타내는 bits
```

맨 왼쪽 비트가 0이면 양수, 1이면 음수로 생각하기로 한 것이다. 정수 표현에 사용하는 bit의 개수는 8개이므로, 나머지 7개의 비트로만 수의 크기를 표현한다.
그러면 표현 가능한 정수 범위가 11111111(-127)-01111111(127)가 된다. 근데 이 방식에는 결정적인 <U>두 가지</U> 단점이 존재한다.  
 1. 계산 시, 부호를 나타내는 bit에 따라 연산을 바꾸어 주어야 한다.
  - 8 + (-7)과, 00001000 + 10000111은 같은 얘기지만 처리 단계로 가면 차이점이 생긴다. 8 + (-7)은 그냥 더해도 결과가 올바르다. 그런데 00001000 + 10000111을 그냥 더하면? 10001111(-15)가 된다. 
  그래서, 앞의 비트를 뚝 뗀 다음, 0001000 - 0000111 = +0000001 => <U>0</U>0000001의 처리 과정을 거쳐야 한다. 
 2. 0이 두 자리나 차지한다. : 00000000(+0) == 10000000(-0)이다.

그래도 뭐... Signed Magnitude는 음수를 -를 달아 표현하는 것과 비슷하니 직관적이다.  
근데 위의 두 가지 문제를 해결할 수 있는 방법이 바로 보수로 표현하는 방법이다. 보수의 종류가 두 가지이니 표현 방식도 두 가지가 된다.
 - Signed 1's Complement : 1의 보수 표현법. 00000000부터 01111111까지는 양수, 10000000부터 11111111까지는 양수의 보수(=음수)로 생각한다. 
 - Signed 2's Complement : 2의 보수 표현법. 1의 보수와 양수, 음수 범위는 동일하다.

Signed Magnitude의 단점으로 지적한 것 중 1번(계산상 처리 문제)은 둘 다 해당하지 않는다. 덧셈이면 바로 더하면 되고, 뺄셈이면 바로 빼면 된다. 그런데 1의 보수 표현법에도 0이 두 개 존재한다. 00000000의 보수를 취하면 11111111이 되어 -0을 만들 수 있다...  
하지만 2의 보수 표현법에서 00000000의 보수를 취하면 11111111 + 1 = (1)00000000 (맨 왼쪽 1은 자릿수를 벗어나서 사라짐)이 되어 -0이 없다. (그래서 2의 보수 표현법은 표현할 수 있는 수가 하나 더 많다. -128)  
결론은 2의 보수 표현법이 참 좋다 되시겠다.    

마무리로, 10001001을 여러 방식으로 읽은 결과표를 보고 어떻게 다른지 살펴보자.

|Unsigned|Signed Magnitude|Signed 1's Complement|Signed 2's Complement|
|---|---|---|---|
|2^7+2^3+1|1(-)0001001(9)|(-)01110110 = (-)118|(-)01110110 + 1 = (-)119|

***
## 5. Binary Code(이진 코드)
이진 코드는 0과 1을 사용하는 코드이다. 결과적으로 2진수와 형태는 유사하지만, 각각의 방식으로 10진수나 부호, 기호, 문자 등등을 표현하는 용도이다.  
따라서 용도별로 다양한 종류의 이진 코드가 존재한다. 그 중 여기서는 BCD Code와 Gray Code, ASCII, Error-detecting Code 네 가지를 다룰 것이다.

### 5-1. BCD Code (8421 Code)
10진수를 표현하는 데 쓰는 이진 코드이다. 10진수의 각 자릿수마다 4bit씩 할당하여 수를 표현한다. 
예를 들어, 5는 1의 자리 수 밖에 없으므로 4bit만으로 표현할 수 있을 것이고, 225는 100의 자리 수까지 있으므로, 총 12bit를 써서 표현해야 할 것이다.  
알기 쉽게 수를 BCD Code로 바꿔 본 예시를 보자.  

|number|6|25|806|3333|
|---|---|---|---|
|BCD Code|0110(6)|0010(2) 0101(5)|1000(8) 0000(0) 0110(6)|0011(3) 0011(3) 0011(3) 0011(3)|

더 설명할 것도 없이 간단하니 좋다. 게다가 2진법이라서 새로운 수 체계를 머리에 입력시킬 필요도 없다. (8421 Code란 이름이 이래서 생겼다. 가중치가 왼쪽부터 8-4-2-1 이라고.)
근데 표현한 결과물이 숫자니까, 계산도 하려면 할 수 있어야 되지 않을까? 덧셈, 뺄셈 방법에 대해서도 설명하겠다.  

**[덧셈하는 방법]**  
각 자릿수끼리 더하면 된다. 그런데, 어느 자릿수의 덧셈 결과가 10을 넘을 수도 있다. 예를 들면 다음과 같은 경우이다.  
```
  0010 0111 (27)
+ 0011 0101 (35)
----------------
  0101 1100 (???)
```

고려해야 할 것이 바로 이 부분이다. 10진수는 숫자가 10개밖에 없는데, 4bit는 0부터 15까지 표현할 수 있다. 따라서, 계산 결과로 나온 값이 10 이상이라면 1의 자리 수만 남기고, 다음 자릿수에 1을 더해줘야 제대로 된 값이 된다.  
예를 들어 위와 같은 경우라면, 1100(12)는 0001 0010으로 바꾸어주어야 한다. 그러기 위해 1100(12)에 0110(6)을 더해 보자, 값은 18이 된다. 그러면 16(<U>1</U>0000)은 4bit에서 벗어난 값이므로 다음 자리수로 1이 넘어가고, 2만 남는다.  
이렇게 10의 자리수만 4bit 바깥으로 밀어내 없애기 위해서는 6을 더하면 된다. 10을 16으로, 11을 17로... 만들 수 있는 수가 6이기 때문이다. 이를 이용해 앞의 잘못된 연산을 바르게 고치면,  

```
  0010 0111 (27)
+ 0011 0101 (35)
----------------
  0101 1100 (>= 1010)
     + 0110 (= 6)
----------------
  0101 0010
+ 0001
----------------
  0111 0010 (62)
```

올바른 결과를 얻을 수 있다.  

**[뺄셈하는 방법]**  
이건 수업에서 다루지 않았던 내용인데, 지금(대략 7주차) 회로 가지고 가산기 감산기 만들면서 BCD Code 얘기를 다시 하려는 느낌이라 한꺼번에 다루고 가겠다.  

BCD Code의 단점 중 하나가 덧셈과 뺄셈 처리 과정이 다르단 것인데, 덧셈과 다르게 뺄셈을 할 때는 보수를 이용한다.  
 1. 감수(subtrahend - 뺄셈 기호 오른쪽에 있는 수)의 <U>1의 보수</U>를 취한다. 
 2. 이 1의 보수를 피감수에 더한다.
 3. 이때, 각 자릿수별로 4bit를 벗어나는 1이 생길 수도 있다. 1이 생긴 자릿수의 다음 자릿수에, 이 1을 더해 준다. 만약 다음 자릿수가 없다면, 1의 자리 수에 그 1을 더한다. 이 과정을 carry라고 부른다. (덧셈에서도 마찬가지)
 4. carry가 일어나지 않은(즉, 4bit를 벗어나는 1이 없었던) 자릿수에는 1010을 더해 준다. 이때 4bit를 벗어난 값이 생긴다면, 그 수는 그냥 버린다.

한국어 정보는 얻기 힘들다고 판단해 영어로 된 글들을 몇 개 참고해서 썼다. 처음에 보고서 두뇌가 잠시 멈췄었는데, MBS니 EAC 같은, 실제 구현에서 써먹을 만한 용어를 싹 제거하고 번역까지 해서 아주 알아듣기 쉽게 고치고 나니 나도 상쾌하다.  
이것도 예시와 함께 보자. 이번에는 35에서 27을 빼 보도록 하자. 

```
  0011 0101 (35)
+ 1101 1000 (1's Complement of 27)
----------------
1 0000 1101 (10의 자리 수에서 carry 발생)

  0000 1101
     +    1 (다음 자릿수(100의 자리)가 없으므로 1의 자리 수에 더한다.)
----------------
  0000 1110
     + 1010 (1의 자리 수에서는 carry가 발생하지 않았으므로 1010을 더한다.)
----------------
    (1)1000 (8)
```

꽤나 복잡한 방법이긴 한데 다른 방식을 찾지 못했다. 만약 시험 문제같은 걸로 출제된다면 그냥 10진법으로 바꿔서 계산하고 BCD로 변환하는 것이 훨씬 빠를 것이다. 이건 회로에게나 시키기로 하자.

### 5-2. Gray Code
마찬가지로 숫자를 표현하는 이진 코드이다. 이 코드는 연산을 위한 수를 나타내는 것이 아니기 때문에, 이거 갖고 사칙연산 하고 있으면 안 된다. 
그런 종류를 보통 '비 가중치 방식 코드'라고 한다. BCD Code같은 가중치 방식 코드는 "0001 0001" 에서, 앞의 0001과 뒤의 0001이 다르다. 자리에 따른 '가중치'가 있기 때문이다. 반면 비 가중치 방식 코드는 자리에 따라 값 크기가 달라지고 하지 않는다.
하여튼, Gray Code는 0부터 시작하여, 한 비트만 바꾸어 가며 다음 수를 표현한다. 말만 들으니 역시 무슨 말인지 잘 감이 안 온다. 다음의 비교 표를 보자.  

|10진법|Binary Code|Gray Code|
|---|---|---|
|0|0000|0000|
|1|0001|0001|
|2|0010|0011|
|3|0011|0010|
|4|0100|0110|
|5|0101|0111|
|6|0110|0101|
|7|0111|0100|
|8|1000|1100|
|9|1001|1101|
|10|1010|1111|

Gray Code를 쭉 훑어보면, 어느 숫자와 인접한 다른 한 숫자는 딱 1 bit씩만 차이가 난다는 것을 알 수 있다.  

근데 왜 이런 코드를 쓸까? 이는 하드웨어의 오류를 최소화하기 위함이다. Binary Code를 보면, 1에서 2로 갈 때, 3에서 4로 갈 때, 7에서 8로 갈 때 등등, 여러 비트가 확 바뀌어버리는 경우가 흔하다.  
따라서 작은 오류에도 큰 오차가 나타날 수 있다. 그러나 Gray Code는 그렇지 않다. 실제로도 입출력 장치, 아날로그-디지털 변환기같이, 연산은 딱히 필요없지만 오차를 최소화해야 하는 분야에서 주로 쓰인다.  
그리고 Karnaugh-map에서도 쓰는데... 한두달 뒤 이걸로 많은 이야기를 하게 될 것 같다.  

### 5-3. ASCII
American Standard Code for Information Interchange의 준말로, 문자를 표현하는 이진 코드이다. 총 7bit를 사용하여 128가지의 문자를 표현할 수 있다.
이 128가지의 문자는 두 종류로 나뉘는데,
 - Graphic Character(94가지) : 대문자, 소문자, 숫자, 특수문자 등 출력이 가능한 문자들.
 - Control Character(34가지) : NULL, BS, DEL 같이 제어를 위한 문자들. 출력이 불가능하다.

딱 규격이 정해진 것이기 때문에 세세한 것은 다루지 않겠다. ASCII 값들이 필요하면 구글링을 하도록 하자. 

### 5-4. Error-detecting Code
전달된 데이터에 오류가 있는지 없는지 검사하는 코드이다. 여기에도 또 여러 종류가 있는데 난 Parity 검사만 배웠기 때문에 이것만 간단히 알아보고 가겠다.
Parity 검사는 다음과 같다. 전달할 데이터에 있는 1의 개수를 홀수 또는 짝수개로 맞추어(패리티 비트를 추가하여) 전달한다. 그러면 그 데이터를 받은 쪽에서 보낸 쪽과 같은 방식으로 해석하여 데이터의 손실이 있는지 검사한다.  
예를 들어, Even Parity bit를 추가하여 1의 개수를 짝수개로 맞추어 보냈는데 전달된 정보의 1의 개수가 홀수개라면 확실히 데이터의 손실이 발생한 것이다.  

근데 이것도 완벽하지는 않다. 아래의 예시를 보자.
```
Even Parity bit 추가

[송신] 00010111 -> [수신] 00100111
=> 에러 없음 (??)
```

무려 2bit나 값이 바뀌었는데 1의 개수는 짝수여서 에러라고 판단하지 못한다. 즉 Parity Check는 1bit짜리 오류만 검사할 수 있다. 
더 괜찮은 오류 검사 코드도 많을 것 같은데 시간상 거기까지는 공부하기 어렵고 방학때나 독학을 해 봐야겠다.  

***